name: Release

on:
  release:
    types: [published]

jobs:
  test:
    name: Run Tests
    uses: ./.github/workflows/test.yml
    with:
      go-version: '1.24'  # Use latest stable or specific version
      run-integration-tests: true
    secrets: inherit

  sbom:
    name: Generate SBOM
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      - name: Install syft
        run: go install github.com/anchore/syft/cmd/syft@v1.5.0
      - name: Generate SPDX SBOM
        run: |
          syft packages dir:. -o spdx-json -o file=sbom.spdx.json
          if [ ! -f sbom.spdx.json ]; then
            echo "Error: SPDX SBOM file not generated"
            exit 1
          fi
          if [ ! -s sbom.spdx.json ]; then
            echo "Error: SPDX SBOM file is empty"
            exit 1
          fi
          echo "SPDX SBOM generated: $(wc -c < sbom.spdx.json) bytes"
      - name: Generate CycloneDX SBOM
        run: |
          syft packages dir:. -o cyclonedx-json -o file=sbom.cyclonedx.json
          if [ ! -f sbom.cyclonedx.json ]; then
            echo "Error: CycloneDX SBOM file not generated"
            exit 1
          fi
          if [ ! -s sbom.cyclonedx.json ]; then
            echo "Error: CycloneDX SBOM file is empty"
            exit 1
          fi
          echo "CycloneDX SBOM generated: $(wc -c < sbom.cyclonedx.json) bytes"
      - name: Validate SBOM files
        run: |
          # Validate JSON syntax using python3 or jq as fallback
          if command -v python3 &> /dev/null; then
            python3 -m json.tool sbom.spdx.json > /dev/null || (echo "Invalid JSON: sbom.spdx.json" && exit 1)
            python3 -m json.tool sbom.cyclonedx.json > /dev/null || (echo "Invalid JSON: sbom.cyclonedx.json" && exit 1)
          elif command -v jq &> /dev/null; then
            jq empty sbom.spdx.json || (echo "Invalid JSON: sbom.spdx.json" && exit 1)
            jq empty sbom.cyclonedx.json || (echo "Invalid JSON: sbom.cyclonedx.json" && exit 1)
          else
            echo "Warning: Neither python3 nor jq available for JSON validation"
            # Basic check: ensure files are not empty and contain JSON-like content
            grep -q '{' sbom.spdx.json || (echo "Invalid JSON: sbom.spdx.json" && exit 1)
            grep -q '{' sbom.cyclonedx.json || (echo "Invalid JSON: sbom.cyclonedx.json" && exit 1)
          fi
          echo "Both SBOM files are valid JSON"
      - name: Upload SBOM files to release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.release.tag_name }}
          files: |
            sbom.cyclonedx.json
            sbom.spdx.json
          fail_on_unmatched_files: true

  changelog:
    name: Generate Changelog
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      - name: Generate changelog
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Helper function to retry API calls with exponential backoff
            async function retryWithBackoff(fn, maxRetries = 3) {
              for (let i = 0; i < maxRetries; i++) {
                try {
                  return await fn();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit') && i < maxRetries - 1) {
                    const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
                    console.log(`Rate limited, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            // Parse conventional commit message
            function parseCommit(commit) {
              const message = commit.commit.message.split('\n')[0]; // First line only
              const match = message.match(/^(\w+)(?:\(([^)]+)\))?:\s*(.+)$/);
              if (!match) return null;
              
              return {
                type: match[1],
                scope: match[2] || '',
                message: match[3],
                author: commit.author?.login || commit.commit.author.name,
                sha: commit.sha.substring(0, 7)
              };
            }
            
            // Group commits by type
            function groupByType(commits) {
              const groups = {};
              const typeLabels = {
                feat: 'Features',
                fix: 'Bug Fixes',
                docs: 'Documentation',
                style: 'Code Style',
                refactor: 'Refactoring',
                perf: 'Performance',
                test: 'Tests',
                chore: 'Chores',
                build: 'Build System',
                ci: 'CI/CD'
              };
              
              commits.forEach(commit => {
                const label = typeLabels[commit.type] || 'Other';
                if (!groups[label]) groups[label] = [];
                groups[label].push(commit);
              });
              
              return groups;
            }
            
            // Format as markdown
            function formatChangelog(groups, tag, date) {
              let changelog = `# Changelog\n\n## ${tag} (${date})\n\n`;
              
              const order = ['Features', 'Bug Fixes', 'Documentation', 'Refactoring', 
                             'Performance', 'Tests', 'Build System', 'CI/CD', 'Code Style', 'Chores', 'Other'];
              
              let hasContent = false;
              order.forEach(label => {
                if (groups[label] && groups[label].length > 0) {
                  hasContent = true;
                  changelog += `### ${label}\n\n`;
                  groups[label].forEach(commit => {
                    const author = commit.author.startsWith('@') ? commit.author : `@${commit.author}`;
                    changelog += `- ${commit.message} (${author})\n`;
                  });
                  changelog += '\n';
                }
              });
              
              if (!hasContent) {
                changelog += '_No changes in this release._\n';
              }
              
              return changelog;
            }
            
            // Main execution
            const currentTag = context.payload.release.tag_name;
            const releaseDate = new Date(context.payload.release.published_at || new Date()).toISOString().split('T')[0];
            
            // Get all tags
            const tags = await retryWithBackoff(async () => {
              return await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
            });
            
            // Find previous tag (semver comparison)
            const tagNames = tags.data.map(t => t.name).sort((a, b) => {
              const aParts = a.replace(/^v/, '').split('.').map(Number);
              const bParts = b.replace(/^v/, '').split('.').map(Number);
              for (let i = 0; i < 3; i++) {
                if (aParts[i] !== bParts[i]) {
                  return bParts[i] - aParts[i];
                }
              }
              return 0;
            });
            
            const currentIndex = tagNames.indexOf(currentTag);
            const previousTag = currentIndex > 0 ? tagNames[currentIndex - 1] : null;
            
            // Get commits
            let commits = [];
            if (previousTag) {
              const comparison = await retryWithBackoff(async () => {
                return await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: previousTag,
                  head: currentTag
                });
              });
              commits = comparison.data.commits;
            } else {
              // First release - get all commits (paginated)
              let page = 1;
              let hasMore = true;
              while (hasMore) {
                const response = await retryWithBackoff(async () => {
                  return await github.rest.repos.listCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    per_page: 100,
                    page: page
                  });
                });
                commits.push(...response.data);
                hasMore = response.data.length === 100;
                page++;
              }
            }
            
            // Parse and filter conventional commits
            const parsed = commits.map(parseCommit).filter(c => c !== null);
            const skipped = commits.length - parsed.length;
            
            if (skipped > 0) {
              console.log(`Skipped ${skipped} non-conventional commits`);
            }
            
            // Group and format
            const grouped = groupByType(parsed);
            const changelog = formatChangelog(grouped, currentTag, releaseDate);
            
            // Write file
            fs.writeFileSync('CHANGELOG.md', changelog);
            
            // Log summary
            console.log(`Generated changelog for ${currentTag}`);
            console.log(`Total commits: ${commits.length}`);
            console.log(`Conventional commits: ${parsed.length}`);
            console.log(`Skipped: ${skipped}`);
            Object.keys(grouped).forEach(type => {
              console.log(`  ${type}: ${grouped[type].length}`);
            });
      - name: Update release notes
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: changelog
            });

  publish:
    name: Verify Release
    needs: [sbom, changelog]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      - name: Verify go.mod
        run: go mod verify
      - name: Verify tag format
        run: |
          TAG="${{ github.event.release.tag_name }}"
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            echo "Error: Tag $TAG does not match semver format (vX.Y.Z)"
            exit 1
          fi
      - name: Verify tag exists
        run: |
          git fetch --tags
          if ! git rev-parse "${{ github.event.release.tag_name }}" >/dev/null 2>&1; then
            echo "Error: Tag ${{ github.event.release.tag_name }} not found"
            exit 1
          fi
          echo "Tag verified: ${{ github.event.release.tag_name }}"
      - name: Verify module
        run: go mod tidy && git diff --exit-code go.mod go.sum
