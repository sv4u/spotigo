name: Release

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - major
          - minor
          - hotfix
      dry_run:
        description: 'Dry run mode (skip tag and release creation)'
        required: false
        type: boolean
        default: false

jobs:
  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      version: ${{ steps.calculate.outputs.version }}
      previous_tag: ${{ steps.calculate.outputs.previous_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Calculate next version
        id: calculate
        uses: actions/github-script@v7
        with:
          script: |
            const bumpType = '${{ inputs.version_bump }}';
            
            // Helper function to retry API calls with exponential backoff
            async function retryWithBackoff(fn, maxRetries = 3) {
              for (let i = 0; i < maxRetries; i++) {
                try {
                  return await fn();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit') && i < maxRetries - 1) {
                    const delay = Math.pow(2, i) * 1000;
                    console.log(`Rate limited, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            // Get all tags
            const tags = await retryWithBackoff(async () => {
              return await github.rest.repos.listTags({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
            });
            
            // Find latest semantic version tag
            const semverTags = tags.data
              .map(t => t.name)
              .filter(tag => /^v\d+\.\d+\.\d+$/.test(tag))
              .sort((a, b) => {
                const aParts = a.replace(/^v/, '').split('.').map(Number);
                const bParts = b.replace(/^v/, '').split('.').map(Number);
                for (let i = 0; i < 3; i++) {
                  if (aParts[i] !== bParts[i]) {
                    return bParts[i] - aParts[i];
                  }
                }
                return 0;
              });
            
            let latestTag = semverTags.length > 0 ? semverTags[0] : null;
            let previousTag = semverTags.length > 1 ? semverTags[1] : null;
            
            // Calculate next version
            let nextVersion;
            if (!latestTag) {
              nextVersion = 'v0.0.1';
              console.log('No existing tags found, starting at v0.0.1');
            } else {
              const version = latestTag.replace(/^v/, '').split('.').map(Number);
              const [major, minor, patch] = version;
              
              switch (bumpType) {
                case 'major':
                  nextVersion = `v${major + 1}.0.0`;
                  break;
                case 'minor':
                  nextVersion = `v${major}.${minor + 1}.0`;
                  break;
                case 'hotfix':
                  nextVersion = `v${major}.${minor}.${patch + 1}`;
                  break;
                default:
                  throw new Error(`Invalid bump type: ${bumpType}`);
              }
              
              console.log(`Latest tag: ${latestTag}`);
              console.log(`Bump type: ${bumpType}`);
              console.log(`Next version: ${nextVersion}`);
            }
            
            // Validate semantic versioning format
            if (!/^v\d+\.\d+\.\d+$/.test(nextVersion)) {
              throw new Error(`Invalid version format: ${nextVersion}`);
            }
            
            // Set outputs
            core.setOutput('version', nextVersion);
            core.setOutput('previous_tag', previousTag || '');
            console.log(`Calculated version: ${nextVersion}`);
            if (previousTag) {
              console.log(`Previous tag: ${previousTag}`);
            } else {
              console.log('No previous tag (first release)');
            }

  test:
    name: Run Tests
    needs: [calculate-version]
    uses: ./.github/workflows/test.yml
    with:
      go-version: '1.24'
      run-integration-tests: true
    secrets: inherit
    permissions:
      pull-requests: write
      contents: read

  sbom:
    name: Generate SBOM
    needs: [test]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      - name: Install syft
        run: go install github.com/anchore/syft/cmd/syft@v1.5.0
      - name: Generate SPDX SBOM
        run: |
          syft packages dir:. -o spdx-json -o file=sbom.spdx.json
          if [ ! -f sbom.spdx.json ]; then
            echo "Error: SPDX SBOM file not generated"
            exit 1
          fi
          if [ ! -s sbom.spdx.json ]; then
            echo "Error: SPDX SBOM file is empty"
            exit 1
          fi
          echo "SPDX SBOM generated: $(wc -c < sbom.spdx.json) bytes"
      - name: Generate CycloneDX SBOM
        run: |
          syft packages dir:. -o cyclonedx-json -o file=sbom.cyclonedx.json
          if [ ! -f sbom.cyclonedx.json ]; then
            echo "Error: CycloneDX SBOM file not generated"
            exit 1
          fi
          if [ ! -s sbom.cyclonedx.json ]; then
            echo "Error: CycloneDX SBOM file is empty"
            exit 1
          fi
          echo "CycloneDX SBOM generated: $(wc -c < sbom.cyclonedx.json) bytes"
      - name: Validate SBOM files
        run: |
          # Validate JSON syntax using python3 or jq as fallback
          if command -v python3 &> /dev/null; then
            python3 -m json.tool sbom.spdx.json > /dev/null || (echo "Invalid JSON: sbom.spdx.json" && exit 1)
            python3 -m json.tool sbom.cyclonedx.json > /dev/null || (echo "Invalid JSON: sbom.cyclonedx.json" && exit 1)
          elif command -v jq &> /dev/null; then
            jq empty sbom.spdx.json || (echo "Invalid JSON: sbom.spdx.json" && exit 1)
            jq empty sbom.cyclonedx.json || (echo "Invalid JSON: sbom.cyclonedx.json" && exit 1)
          else
            echo "Warning: Neither python3 nor jq available for JSON validation"
            # Basic check: ensure files are not empty and contain JSON-like content
            grep -q '{' sbom.spdx.json || (echo "Invalid JSON: sbom.spdx.json" && exit 1)
            grep -q '{' sbom.cyclonedx.json || (echo "Invalid JSON: sbom.cyclonedx.json" && exit 1)
          fi
          echo "Both SBOM files are valid JSON"
      - name: Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-files
          path: |
            sbom.spdx.json
            sbom.cyclonedx.json
          retention-days: 7

  changelog:
    name: Generate Changelog
    needs: [test, calculate-version]
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      changelog_path: ${{ steps.generate.outputs.changelog_path }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'
      - name: Generate changelog
        id: generate
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const currentTag = '${{ needs.calculate-version.outputs.version }}';
            const previousTag = '${{ needs.calculate-version.outputs.previous_tag }}';
            const releaseDate = new Date().toISOString().split('T')[0];
            
            // Helper function to retry API calls with exponential backoff
            async function retryWithBackoff(fn, maxRetries = 3) {
              for (let i = 0; i < maxRetries; i++) {
                try {
                  return await fn();
                } catch (error) {
                  if (error.status === 403 && error.message.includes('rate limit') && i < maxRetries - 1) {
                    const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
                    console.log(`Rate limited, retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            // Parse conventional commit message
            function parseCommit(commit) {
              const message = commit.commit.message.split('\n')[0]; // First line only
              const match = message.match(/^(\w+)(?:\(([^)]+)\))?:\s*(.+)$/);
              if (!match) return null;
              
              return {
                type: match[1],
                scope: match[2] || '',
                message: match[3],
                author: commit.author?.login || commit.commit.author.name,
                sha: commit.sha.substring(0, 7)
              };
            }
            
            // Group commits by type
            function groupByType(commits) {
              const groups = {};
              const typeLabels = {
                feat: 'Features',
                fix: 'Bug Fixes',
                docs: 'Documentation',
                style: 'Code Style',
                refactor: 'Refactoring',
                perf: 'Performance',
                test: 'Tests',
                chore: 'Chores',
                build: 'Build System',
                ci: 'CI/CD'
              };
              
              commits.forEach(commit => {
                const label = typeLabels[commit.type] || 'Other';
                if (!groups[label]) groups[label] = [];
                groups[label].push(commit);
              });
              
              return groups;
            }
            
            // Format as markdown
            function formatChangelog(groups, tag, date) {
              let changelog = `# Changelog\n\n## ${tag} (${date})\n\n`;
              
              const order = ['Features', 'Bug Fixes', 'Documentation', 'Refactoring', 
                             'Performance', 'Tests', 'Build System', 'CI/CD', 'Code Style', 'Chores', 'Other'];
              
              let hasContent = false;
              order.forEach(label => {
                if (groups[label] && groups[label].length > 0) {
                  hasContent = true;
                  changelog += `### ${label}\n\n`;
                  groups[label].forEach(commit => {
                    const author = commit.author.startsWith('@') ? commit.author : `@${commit.author}`;
                    changelog += `- ${commit.message} (${author})\n`;
                  });
                  changelog += '\n';
                }
              });
              
              if (!hasContent) {
                changelog += '_No changes in this release._\n';
              }
              
              return changelog;
            }
            
            // Get commits
            let commits = [];
            if (previousTag && previousTag !== '') {
              // Compare from previous tag to current HEAD
              const comparison = await retryWithBackoff(async () => {
                return await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: previousTag,
                  head: context.sha
                });
              });
              commits = comparison.data.commits;
              console.log(`Comparing ${previousTag}..${context.sha}`);
            } else {
              // First release - get all commits (paginated)
              console.log('First release - getting all commits');
              let page = 1;
              let hasMore = true;
              while (hasMore) {
                const response = await retryWithBackoff(async () => {
                  return await github.rest.repos.listCommits({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    per_page: 100,
                    page: page
                  });
                });
                commits.push(...response.data);
                hasMore = response.data.length === 100;
                page++;
              }
            }
            
            // Parse and filter conventional commits
            const parsed = commits.map(parseCommit).filter(c => c !== null);
            const skipped = commits.length - parsed.length;
            
            if (skipped > 0) {
              console.log(`Skipped ${skipped} non-conventional commits`);
            }
            
            // Group and format
            const grouped = groupByType(parsed);
            const changelog = formatChangelog(grouped, currentTag, releaseDate);
            
            // Write file
            fs.writeFileSync('CHANGELOG.md', changelog);
            
            // Log summary
            console.log(`Generated changelog for ${currentTag}`);
            console.log(`Total commits: ${commits.length}`);
            console.log(`Conventional commits: ${parsed.length}`);
            console.log(`Skipped: ${skipped}`);
            Object.keys(grouped).forEach(type => {
              console.log(`  ${type}: ${grouped[type].length}`);
            });
            
            core.setOutput('changelog_path', 'CHANGELOG.md');
      - name: Upload changelog artifact
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG.md
          retention-days: 7

  dry-run-summary:
    name: Dry Run Summary
    needs: [calculate-version, sbom, changelog]
    if: inputs.dry_run == true
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Download changelog artifact
        uses: actions/download-artifact@v4
        with:
          name: changelog
          path: .
      - name: Display summary
        run: |
          echo "## Dry Run Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Tag:** ${{ needs.calculate-version.outputs.previous_tag || 'None (first release)' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** ${{ inputs.version_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What would be created:" >> $GITHUB_STEP_SUMMARY
          echo "- Git tag: ${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub Release: ${{ needs.calculate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- SBOM files: sbom.spdx.json, sbom.cyclonedx.json" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Changelog Preview:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          head -20 CHANGELOG.md >> $GITHUB_STEP_SUMMARY || echo "Changelog preview unavailable" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** No tag or release was created (dry-run mode)" >> $GITHUB_STEP_SUMMARY

  create-release:
    name: Create Release
    needs: [calculate-version, sbom, changelog]
    if: inputs.dry_run == false
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Download SBOM artifacts
        uses: actions/download-artifact@v4
        with:
          name: sbom-files
          path: ./sbom
      - name: Download changelog artifact
        uses: actions/download-artifact@v4
        with:
          name: changelog
          path: .
      - name: Create Git tag
        run: |
          VERSION="${{ needs.calculate-version.outputs.version }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.calculate-version.outputs.version }}
          name: ${{ needs.calculate-version.outputs.version }}
          body_path: CHANGELOG.md
          files: |
            sbom/sbom.spdx.json
            sbom/sbom.cyclonedx.json
          fail_on_unmatched_files: true
          draft: false
          prerelease: false
